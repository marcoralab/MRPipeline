---
title: 'Mendelian Randomization: <trait> and Alzheimers disease'
author: "Shea Andrews"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: true
    number_sections: true
    toc_depth: 4
    toc_float:
      collapsed: false
      smooth_scroll: false
editor_options:
  chunk_output_type: console
params:
  trait1.summary: 
  trait1.clump: 
  trait1.name: 
  trait1.blurb: 
  trait1.code: 
  trait2.summary: 
  trait2.clump: 
  trait2.name: 
  trait2.blurb: 
  trait2.code: 
  out.path: 
  p.threshold: 
---

## Data sources
`r params$trait1.blurb`

`r params$trait2.blurb`

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### ===== Load packages ===== ###

suppressMessages(library(tidyverse))   ## For data wrangling
suppressMessages(library(Hmisc))       ## Contains miscillaneous funtions
suppressMessages(library(TwoSampleMR)) ## For conducting MR https://mrcieu.github.io/TwoSampleMR/
suppressMessages(library(haploR))      ## For searching for proxy snps

##  ---- Find Proxy SNPs - uses haploR ---- ##
FindProxys <-function(snplist, dat){
  ProxySnps <- queryHaploreg(query = snplist, ldThresh = 0.8,
              ldPop = "EUR", timeout = 100, encoding = "UTF-8", verbose = TRUE) %>% 
  select(query_snp_rsid, rsID, chr, pos_hg38, r2, `D'`, is_query_snp, ref, alt) %>% 
  rename(ld.r2 = r2, Dprime = `D'`)

query_snps <- ProxySnps %>% filter(is_query_snp == 1) %>% select(query_snp_rsid, ref, alt)

proxy.snps <- left_join(ProxySnps, dat, by = c('rsID' = 'SNP')) %>% 
  filter(!is.na(Effect_allele)) %>%                       ## remove snps with missing information
  filter(is_query_snp == 0) %>%                           ## remove query snps
  filter(nchar(ref) == 1) %>% filter(nchar(alt) == 1) %>% ## remove indels
  group_by(query_snp_rsid) %>%                            ## by query snp
  arrange(-ld.r2) %>%                                     ## arrange by ld
  slice(1) %>%                                            ## select top proxy snp
  ungroup() %>% 
  rename(Effect_allele.proxy = Effect_allele, Non_Effect_allele.proxy = Non_Effect_allele) %>% ## rename alleles
  select(-chr, -pos_hg38, -is_query_snp) %>%              ## remove uneeded columns
  ## Join proxy snps to query snps
  left_join(query_snps, by = 'query_snp_rsid', suffix = c('.proxy', "")) %>% 
  ## for each proxy snp, coded correlated allels
  mutate(Effect_allele = ifelse(Effect_allele.proxy == ref.proxy, ref, alt)) %>%
  mutate(Non_Effect_allele = ifelse(Non_Effect_allele.proxy == ref.proxy, ref, alt)) %>% 
  rename(SNP = query_snp_rsid) 

proxy.snps
}

```

```{r datain, include=FALSE, echo=FALSE, cache=F}
### ===== Load Summary Statisitics ===== ###
## Assumes summayr statsticsts have the following column names:  
#   1. SNP           
#   2. CHR    
#   3. POS 
#   4. Effect_allele 
#   5. Non_Effect_allele   
#   6. EAF    
#   7. Beta     
#   8. SE     
#   9. P       
#   10. r2     
#   11. N
## ---- Trait ---- ##
trait1.dat <- read_tsv(params$trait1.summary) 
trait1.exp <- filter(trait1.dat, P < as.numeric(params$p.threshold))

## ---- Trait ---- ##
trait2.dat <- read_tsv(params$trait2.summary)
trait2.exp <- filter(trait2.dat, P < as.numeric(params$p.threshold))

```

## Instrumental Vaibles
**LD Clumping:** For standard two sample MR it is important to ensure that the instruments for the exposure are independent. LD clumping can be performed using the data_clump function from the TwoSampleMR package, which uses EUR samples from the 1000 genomes project to estimate LD between SNPs and amonst SNPs that have and LD above a given threshold, only the SNP with the lowest p-value will be retained.
<br>

**Proxy SNPs:** Where SNPs were not available in the outcome GWAS, the EUR thousand genomes was queried to identified potential proxy SNPs that are in linkage disequilibrium (r2 > 0.8) of the missing SNP.

### `r params$trait1.name`
```{r LD_clumpting trait1, echo=F, message=F, warning=F, cache=F}
Nsnps <- nrow(trait1.exp)

if(params$trait1.clump == 'None'){
  ## Convert to TwoSampleMR format to apply LD clumping
  mr_trait1.exp <- format_data(trait1.exp, type = 'exposure',
                              phenotype_col = 'trait1',
                              snp_col = 'SNP',
                              beta_col = "Beta",
                              se_col = "SE",
                              eaf_col = "EAF",
                              effect_allele_col = "Effect_allele",
                              other_allele_col = "Non_Effect_allele",
                              pval_col = "P")
  mr_trait1.exp <- mutate(mr_trait1.exp, exposure = 'trait1')
  ## Clump 
  mr_trait1.exp_ld <- clump_data(mr_trait1.exp, clump_r2 = 0.1, clump_kb = 250)
  
} else {
  ## Plink Pre-clumped
  mr_trait1.exp_ld <- read_table2(params$trait1.clump) %>% 
    filter(!is.na(CHR)) %>% 
    select(CHR, F, SNP, BP, P, TOTAL, NSIG)
}

#and filter
trait1.exp <- trait1.exp %>% filter(SNP %in% mr_trait1.exp_ld$SNP)
```

`r params$trait1.name`: `r Nsnps` SNPs (Table 1) were assoicated with were associated with `r params$trait1.name` at p < `r params$p.threshold`. After LD clumping, `r Nsnps - nrow(trait1.exp)` of `r Nsnps` SNPs were removed.
<br>
  
  **Table 1:** Independent SNPS associated with `r params$trait1.name`
```{r trait1_table, echo=FALSE, message=F}
as.data.frame(trait1.exp)
```
<br>


```{r data_joining trait1_trait2, warning=FALSE, echo=FALSE, cache=F}
trait2.out <- trait2.dat %>%
  right_join(select(trait1.exp, SNP), by = 'SNP')

miss.trait2.out <- filter(trait2.out, is.na(CHR))

# If snps are missing, find proxy snp
if(nrow(miss.trait2.out) >= 1){
  # Search for Proxy SNPs
  proxy.trait2.out <- FindProxys(miss.trait2.out$SNP, trait2.dat)

  # Combine proxy snps with trait data
  trait2.out <- trait2.out %>%
    filter(SNP %nin% miss.trait2.out$SNP) %>%
    bind_rows(select(proxy.trait2.out, SNP, CHR, POS, Effect_allele, Non_Effect_allele, EAF, Beta, SE, P, r2, N)) %>%
    arrange(CHR, POS)
}

```

Of the the `r nrow(trait1.exp)` SNPs associated with `r params$trait1.name`, `r nrow(trait1.exp) - nrow(miss.trait2.out)` were available in the `r params$trait2.name` GWAS (Table 2).


**Table 2:** SNPS associated with `r params$trait1.name` avalible in `r params$trait2.name` GWAS
```{r trait1_LOAD_table, echo=FALSE}
as.data.frame(trait2.out)
```
<br>  


### `r params$trait2.name`
```{r LD_clumpting trait2, echo=F, message=F, warning=F, cache=F}
Nsnps <- nrow(trait2.exp)

if(params$trait2.clump == 'None'){
  ## Convert to TwoSampleMR format to apply LD clumping
  mr_trait2.exp <- format_data(trait2.exp, type = 'exposure',
                               phenotype_col = 'trait2',
                               snp_col = 'SNP',
                               beta_col = "Beta",
                               se_col = "SE",
                               eaf_col = "EAF",
                               effect_allele_col = "Effect_allele",
                               other_allele_col = "Non_Effect_allele",
                               pval_col = "P")
  mr_trait2.exp <- mutate(mr_trait2.exp, exposure = 'trait2')
  ## Clump 
  mr_trait2.exp_ld <- clump_data(mr_trait2.exp, clump_r2 = 0.1, clump_kb = 250)
  
} else {
  ## Plink Pre-clumped
  mr_trait2.exp_ld <- read_table2(params$trait2.clump) %>% 
    filter(!is.na(CHR)) %>% 
    select(CHR, F, SNP, BP, P, TOTAL, NSIG)
}

#and filter
trait2.exp <- trait2.exp %>% filter(SNP %in% mr_trait2.exp_ld$SNP)
```

`r params$trait2.name`: `r Nsnps` SNPs (Table 3) were assoicated with were associated with `r params$trait2.name` at p < `r params$p.threshold`. After LD clumping, `r Nsnps - nrow(trait2.exp)` of `r Nsnps` SNPs were removed.
<br>
  
**Table 3:** Independent SNPS associated with `r params$trait2.name`
```{r trait2_table, echo=FALSE, message=F}
as.data.frame(trait2.exp)
```
<br>
  
  
```{r data_joining trait2_trait1, warning=FALSE, echo=FALSE, cache=F}
trait1.out <- trait1.dat %>%
  right_join(select(trait2.exp, SNP), by = 'SNP')

miss.trait1.out <- filter(trait1.out, is.na(CHR))

# If snps are missing, find proxy snp
if(nrow(miss.trait1.out) >= 1){
  # Search for Proxy SNPs
  proxy.trait1.out <- FindProxys(miss.trait1.out$SNP, trait1.dat)

  # Combine proxy snps with trait data
  trait1.out <- trait1.out %>%
    filter(SNP %nin% miss.trait1.out$SNP) %>%
    bind_rows(select(proxy.trait1.out, SNP, CHR, POS, Effect_allele, Non_Effect_allele, EAF, Beta, SE, P, r2, N)) %>%
    arrange(CHR, POS)
}
```

Of the the `r nrow(trait2.exp)` SNPs associated with `r params$trait2.name`, `r nrow(trait2.exp) - nrow(miss.trait1.out)` were available in the `r params$trait1.name` GWAS (Table 4).


**Table 4:** SNPS associated with `r params$trait2.name` avalible in `r params$trait1.name` GWAS
```{r trait2_LOAD_table, echo=FALSE}
as.data.frame(trait1.out)
```
<br>  
  

## Data harmonization
Harmonize the exposure and outcome datasets so that the effect of a SNP on the exposure and the effect of that SNP on the outcome correspond to the same allele. The harmonise_data function from the TwoSampleMR package can be used to perform the harmonization step, by default it try's to infer the forward strand alleles using allele frequency information. EAF were not availbe in the IGAP summary statisitics, as such the allele frequencies reported in the AAOS anaylsis were used.
<br>

### Exposure: `r params$trait1.name` ~ Outcome: `r params$trait2.name`
```{r format_trait1_exp, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# Format Trait1 Exposure
mr_trait1.exp <- format_data(trait1.exp, type = 'exposure',
                               phenotype_col = 'trait1',
                               snp_col = 'SNP',
                               beta_col = "Beta",
                               se_col = "SE",
                               eaf_col = "EAF",
                               effect_allele_col = "Effect_allele",
                               other_allele_col = "Non_Effect_allele",
                               pval_col = "P")
mr_trait1.exp <- mutate(mr_trait1.exp, exposure = params$trait1.code)
```


```{r format_trait2_out, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# Format Trait2 Outcome
mr_trait2.out <- format_data(trait2.out, type = 'outcome',
                          phenotype_col = 'AD',
                          snp_col = 'SNP',
                          beta_col = "Beta",
                          se_col = "SE",
                          eaf_col = "EAF",
                          effect_allele_col = "Effect_allele",
                          other_allele_col = "Non_Effect_allele",
                          pval_col = "P")
mr_trait2.out <- mutate(mr_trait2.out, outcome = params$trait2.code)
```

```{r harmonize_trait1_exp_trait2_out, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# harmonize LOAD
trait1.exp_trait2.out.MRdat <- harmonise_data(mr_trait1.exp, mr_trait2.out)
```

**Table 5:** Harmonized `r params$trait.name` and LOAD datasets
```{r trait1_LOAD, echo=FALSE, cache=F}
as.data.frame(trait1.exp_trait2.out.MRdat %>%
  select(SNP, effect_allele.exposure, other_allele.exposure, effect_allele.outcome, other_allele.outcome, beta.exposure, beta.outcome, eaf.exposure, eaf.outcome, se.outcome, pval.outcome, se.exposure, pval.exposure))
```
<br>

### Exposure: `r params$trait2.name` ~ Outcome: `r params$trait1.name`
```{r format_trait2_exp, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# Format trait2 Exposure
mr_trait2.exp <- format_data(trait2.exp, type = 'exposure',
                             phenotype_col = 'trait2',
                             snp_col = 'SNP',
                             beta_col = "Beta",
                             se_col = "SE",
                             eaf_col = "EAF",
                             effect_allele_col = "Effect_allele",
                             other_allele_col = "Non_Effect_allele",
                             pval_col = "P")
mr_trait2.exp <- mutate(mr_trait2.exp, exposure = params$trait2.code)
```


```{r format_trait1_out, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# Format trait1 Outcome
mr_trait1.out <- format_data(trait1.out, type = 'outcome',
                             phenotype_col = 'AD',
                             snp_col = 'SNP',
                             beta_col = "Beta",
                             se_col = "SE",
                             eaf_col = "EAF",
                             effect_allele_col = "Effect_allele",
                             other_allele_col = "Non_Effect_allele",
                             pval_col = "P")
mr_trait1.out <- mutate(mr_trait1.out, outcome = params$trait1.code)
```

```{r harmonize_trait2_exp_trait1_out, warning=FALSE, echo=FALSE, include=FALSE, cache=F}
# harmonize LOAD
trait2.exp_trait1.out.MRdat <- harmonise_data(mr_trait2.exp, mr_trait1.out)
```

**Table 5:** Harmonized `r params$trait.name` and LOAD datasets
```{r trait2_LOAD, echo=FALSE, cache=F}
as.data.frame(trait2.exp_trait1.out.MRdat %>%
                select(SNP, effect_allele.exposure, other_allele.exposure, effect_allele.outcome, other_allele.outcome, beta.exposure, beta.outcome, eaf.exposure, eaf.outcome, se.outcome, pval.outcome, se.exposure, pval.exposure))
```
<br>
  
```{r write, echo=FALSE, message=F, warning=F, include=F}
write_csv(trait1.exp_trait2.out.MRdat, paste0(params$out.path, params$trait1.code, '/', params$trait1.code, '_', params$trait2.code, '_', params$p.threshold, '_MRdat.csv'))
write_csv(trait2.exp_trait1.out.MRdat, paste0(params$out.path, params$trait2.code, '/', params$trait2.code, '_', params$trait1.code, '_', params$p.threshold, '_MRdat.csv'))
```

